<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interfone Digital - Porteiro</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 30px;
            width: 100%;
            max-width: 800px;
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .header h1 {
            color: #333;
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header .subtitle {
            color: #666;
            font-size: 1.1rem;
            font-weight: 500;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            border: 1px solid #e9ecef;
        }

        .panel h3 {
            color: #495057;
            margin-bottom: 20px;
            font-size: 1.3rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #495057;
            font-weight: 500;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            min-width: 120px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(86, 171, 47, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 65, 108, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .connection-status {
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.1rem;
        }

        .connection-status.connected {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .connection-status.calling {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            color: #856404;
            border: 1px solid #ffeaa7;
            animation: pulse 2s infinite;
        }

        .connection-status.disconnected {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .residents-list {
            max-height: 300px;
            overflow-y: auto;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            background: white;
        }

        .resident-item {
            padding: 15px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s ease;
        }

        .resident-item:hover {
            background-color: #f8f9fa;
        }

        .resident-item:last-child {
            border-bottom: none;
        }

        .resident-info {
            flex: 1;
        }

        .resident-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .resident-apartment {
            color: #666;
            font-size: 0.9rem;
        }

        .resident-status {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: #d4edda;
            color: #155724;
        }

        .resident-status.online {
            background: #d4edda;
            color: #155724;
        }

        .resident-status.offline {
            background: #f8d7da;
            color: #721c24;
        }

        .call-status-area {
            display: none;
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            margin-top: 20px;
        }

        .call-status-area h4 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .calling-residents {
            display: grid;
            gap: 10px;
            margin-top: 15px;
        }

        .calling-resident {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
        }

        .calling-resident.answered {
            border-left-color: #28a745;
            background: #d4edda;
        }

        .calling-resident.cancelled {
            border-left-color: #6c757d;
            background: #e2e3e5;
        }

        .calling-resident.failed {
            border-left-color: #dc3545;
            background: #f8d7da;
        }

        .calling-status {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .calling-status.calling {
            color: #856404;
        }

        .calling-status.answered {
            color: #155724;
        }

        .calling-status.cancelled {
            color: #495057;
        }

        .calling-status.failed {
            color: #721c24;
        }

        .call-controls {
            display: none;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .call-info {
            display: none;
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            margin-top: 20px;
        }

        .call-info h4 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .call-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .call-detail {
            text-align: center;
        }

        .call-detail-label {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .call-detail-value {
            color: #333;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }

        .volume-bar {
            flex: 1;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
        }

        .volume-level {
            height: 100%;
            background: linear-gradient(90deg, #56ab2f 0%, #a8e6cf 100%);
            width: 0%;
            transition: width 0.1s ease;
        }

        .log-container {
            background: #2c3e50;
            color: #ecf0f1;
            border-radius: 10px;
            padding: 20px;
            margin-top: 30px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 5px 0;
            border-bottom: 1px solid #34495e;
        }

        .log-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .log-entry.info { color: #3498db; }
        .log-entry.success { color: #2ecc71; }
        .log-entry.warning { color: #f39c12; }
        .log-entry.error { color: #e74c3c; }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }

            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .call-controls {
                grid-template-columns: 1fr;
            }

            .call-details {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üö™ Interfone Digital</h1>
            <div class="subtitle">Painel do Porteiro</div>
        </div>

        <div id="connectionStatus" class="connection-status disconnected">
            <span>üî¥</span>
            <span>Desconectado - Aguardando conex√£o</span>
        </div>

        <div class="main-content">
            <div class="panel">
                <h3>üè¢ Buscar Apartamento</h3>
                <div class="form-group">
                    <label for="buildingSelect">Pr√©dio:</label>
                    <select id="buildingSelect">
                        <option value="">Selecione um pr√©dio...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="apartmentInput">Apartamento:</label>
                    <input type="text" id="apartmentInput" placeholder="Ex: 101, 202A, etc.">
                </div>
                <button class="btn btn-primary" onclick="callApartment()">
                    <span>üìû</span> Chamar Apartamento
                </button>
            </div>

            <div class="panel">
                <h3>üë• Moradores do Apartamento</h3>
                <div id="residentsList" class="residents-list">
                    <div style="padding: 40px; text-align: center; color: #666;">
                        Busque um apartamento para ver os moradores
                    </div>
                </div>
            </div>
        </div>

        <div id="callStatusArea" class="call-status-area">
            <h4>üìû Status da Chamada</h4>
            <div id="callStatusMessage" style="margin-bottom: 15px; font-weight: 600;"></div>
            <div id="callingResidents" class="calling-residents"></div>
        </div>

        <div id="callControls" class="call-controls">
            <button class="btn btn-success" id="answerCall" onclick="answerCall()" disabled>
                <span>üìû</span> Atender
            </button>
            <button class="btn btn-danger" id="endCall" onclick="endCall()" disabled>
                <span>üì¥</span> Encerrar
            </button>
            <button class="btn btn-primary" id="muteButton" onclick="toggleMute()">
                <span>üîá</span> Mute
            </button>
            <button class="btn btn-primary" onclick="testMicrophone()">
                <span>üé§</span> Testar Mic
            </button>
        </div>

        <div id="callInfo" class="call-info">
            <h4>üìä Informa√ß√µes da Chamada</h4>
            <div class="call-details">
                <div class="call-detail">
                    <div class="call-detail-label">Morador</div>
                    <div class="call-detail-value" id="currentResident">-</div>
                </div>
                <div class="call-detail">
                    <div class="call-detail-label">Apartamento</div>
                    <div class="call-detail-value" id="currentApartment">-</div>
                </div>
                <div class="call-detail">
                    <div class="call-detail-label">Dura√ß√£o</div>
                    <div class="call-detail-value" id="callDuration">00:00</div>
                </div>
                <div class="call-detail">
                    <div class="call-detail-label">Status</div>
                    <div class="call-detail-value" id="callStatus">-</div>
                </div>
            </div>
            <div class="volume-control">
                <span>üîä Volume Microfone:</span>
                <div class="volume-bar">
                    <div class="volume-level" id="volumeLevel"></div>
                </div>
            </div>
            <div class="volume-control">
                <span>üîä Volume √Åudio Recebido:</span>
                <input type="range" id="remoteVolumeSlider" min="0" max="1" step="0.1" value="1" 
                       style="width: 100%; margin-top: 5px;" onchange="adjustRemoteVolume(this.value)">
                <span id="remoteVolumeValue" style="font-size: 0.9em; color: #666;">100%</span>
            </div>
        </div>

        <!-- Elemento de √°udio para reprodu√ß√£o do √°udio remoto -->
        <audio id="remoteAudio" autoplay playsinline style="display: none;"></audio>

        <div class="log-container">
            <div id="logContainer">
                <div class="log-entry info">Sistema iniciado - Aguardando conex√£o...</div>
            </div>
        </div>
    </div>

    <script>
        // Configura√ß√µes do Supabase
        const SUPABASE_URL = 'https://ycamhxzumzkpxuhtugxc.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InljYW1oeHp1bXprcHh1aHR1Z3hjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU3MjEwMzEsImV4cCI6MjA3MTI5NzAzMX0.CBgkeAVbxlyJHftmVWSkSPefrbOdMckMvtakRTDpgc8';
        
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // WebRTCService para integra√ß√£o com Supabase e WebSocket
        class WebRTCService {
            constructor() {
                this.supabase = supabase;
                this.socket = null;
                this.isConnected = false;
            }

            // Conectar ao WebSocket
            async connectWebSocket() {
                try {
                    // Importar Socket.IO client
                    const script = document.createElement('script');
                    script.src = 'https://cdn.socket.io/4.8.1/socket.io.min.js';
                    document.head.appendChild(script);
                    
                    return new Promise((resolve, reject) => {
                        script.onload = () => {
                            // Conectar ao servidor WebSocket
                            this.socket = io('ws://localhost:3001', {
                                auth: {
                                    token: 'porteiro-token', // Token de autentica√ß√£o do porteiro
                                    userType: 'porteiro',
                                    userId: 'porteiro-001'
                                }
                            });

                            this.socket.on('connect', () => {
                                console.log('Conectado ao WebSocket');
                                this.isConnected = true;
                                this.setupWebSocketEvents();
                                resolve();
                            });

                            this.socket.on('disconnect', () => {
                                console.log('Desconectado do WebSocket');
                                this.isConnected = false;
                            });

                            this.socket.on('connect_error', (error) => {
                                console.error('Erro de conex√£o WebSocket:', error);
                                reject(error);
                            });
                        };
                        
                        script.onerror = reject;
                    });
                } catch (error) {
                    console.error('Erro ao conectar WebSocket:', error);
                    throw error;
                }
            }

            // Configurar eventos WebSocket
            setupWebSocketEvents() {
                // Resposta de chamada aceita
                this.socket.on('webrtc:call:answered', (data) => {
                    const { callId, answer } = data;
                    console.log('Chamada aceita:', callId);
                    
                    if (currentCall && currentCall.id === callId) {
                        handleCallAccepted(data);
                    }
                });

                // Chamada rejeitada
                this.socket.on('webrtc:call:rejected', (data) => {
                    const { callId, reason } = data;
                    console.log('Chamada rejeitada:', callId, reason);
                    
                    if (currentCall && currentCall.id === callId) {
                        handleCallRejected(data);
                    }
                });

                // Erro na chamada
                this.socket.on('webrtc:error', (error) => {
                    console.error('Erro WebRTC:', error);
                    log(`‚ùå Erro: ${error.message}`, 'error');
                });

                // Confirma√ß√£o de chamada enviada
                this.socket.on('webrtc:call:sent', (data) => {
                    console.log('Chamada enviada com sucesso:', data.callId);
                });
            }

            async getBuildings() {
                try {
                    const { data, error } = await this.supabase
                        .from('buildings')
                        .select('*')
                        .order('name');
                    
                    if (error) throw error;
                    return data || [];
                } catch (error) {
                    console.error('Erro ao buscar pr√©dios:', error);
                    // Retornar dados mock para teste
                    return [
                        { id: 'building-1', name: 'Edif√≠cio Teste A' },
                        { id: 'building-2', name: 'Edif√≠cio Teste B' }
                    ];
                }
            }

            async getBuildingApartments(buildingId) {
                try {
                    const { data, error } = await this.supabase
                        .from('apartments')
                        .select('*')
                        .eq('building_id', buildingId)
                        .order('number');
                    
                    if (error) throw error;
                    return data || [];
                } catch (error) {
                    console.error('Erro ao buscar apartamentos:', error);
                    // Retornar dados mock para teste
                    return [
                        { id: 'apt-101', building_id: buildingId, number: '101', floor: 1 },
                        { id: 'apt-102', building_id: buildingId, number: '102', floor: 1 },
                        { id: 'apt-201', building_id: buildingId, number: '201', floor: 2 }
                    ];
                }
            }

            async getApartmentResidents(apartmentNumber, buildingId) {
                try {
                    console.log('üîç Buscando moradores para apartamento:', apartmentNumber, 'no pr√©dio:', buildingId);
                    const { data, error } = await this.supabase
                        .rpc('get_apartment_residents', { 
                            apartment_number: apartmentNumber, 
                            building_id: buildingId 
                        });
                    
                    if (error) {
                        console.error('‚ùå Erro na RPC get_apartment_residents:', error);
                        throw error;
                    }
                    
                    console.log('‚úÖ Moradores encontrados:', data);
                    return data || [];
                } catch (error) {
                    console.error('Erro ao buscar moradores:', error);
                    console.error('Detalhes do erro:', error.message);
                    // Retornar array vazio em caso de erro
                    return [];
                }
            }

            async initiateCall(apartmentId, visitorName, residents) {
                try {
                    if (!this.isConnected) {
                        throw new Error('WebSocket n√£o conectado');
                    }

                    // Gerar ID √∫nico para a chamada
                    const callId = `call-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    
                    // Enviar chamada via WebSocket para cada morador
                    for (const resident of residents) {
                        this.socket.emit('webrtc:call:initiate', {
                            callId: callId,
                            callerId: 'porteiro-001',
                            receiverId: resident.profile_id,
                            apartmentId: apartmentId,
                            visitorName: visitorName,
                            offer: null // Ser√° preenchido quando estabelecer WebRTC
                        });
                    }

                    return {
                        success: true,
                        call_id: callId,
                        message: 'Chamada iniciada com sucesso'
                    };
                } catch (error) {
                    console.error('Erro ao iniciar chamada:', error);
                    throw error;
                }
            }
        }

        // Fun√ß√µes para lidar com respostas de chamada
        function handleCallAccepted(data) {
            const { callId, answer, resident_id, resident_name } = data;
            
            if (!currentCall || currentCall.id !== callId) {
                return;
            }
            
            log(`‚úÖ ${resident_name} aceitou a chamada!`, 'success');
            updateCallStatusMessage(`Conectado com ${resident_name}`);
            
            // Atualizar status: apenas quem atendeu fica como "answered", outros como "cancelled"
            const callingList = currentCall.residents.map(resident => ({
                id: resident.profile_id,
                name: resident.full_name,
                status: resident.profile_id === resident_id ? 'answered' : 'cancelled'
            }));
            
            updateCallingResidentsList(callingList);
            
            // Atualizar status da chamada
            currentCall.status = 'connected';
            currentCall.connectedResident = {
                id: resident_id,
                name: resident_name
            };
            
            // Estabelecer conex√£o WebRTC
            establishConnection(resident_id, resident_name, currentCall.apartment);
        }

        function handleCallRejected(data) {
            const { callId, reason, resident_id, resident_name } = data;
            
            if (!currentCall || currentCall.id !== callId) {
                return;
            }
            
            log(`‚ùå ${resident_name} rejeitou a chamada`, 'warning');
            
            // Remover morador da lista de chamadas ativas
            currentCall.residents = currentCall.residents.filter(r => r.profile_id !== resident_id);
            
            // Verificar se ainda h√° moradores para atender
            if (currentCall.residents.length === 0) {
                // Todos rejeitaram
                updateCallStatusMessage('Chamada rejeitada por todos os moradores');
                
                const callingList = [{
                    id: resident_id,
                    name: resident_name,
                    status: 'rejected'
                }];
                
                updateCallingResidentsList(callingList);
                currentCall = null;
            } else {
                // Atualizar lista removendo quem rejeitou
                const callingList = currentCall.residents.map(resident => ({
                    id: resident.profile_id,
                    name: resident.full_name,
                    status: 'calling'
                }));
                
                updateCallingResidentsList(callingList);
            }
        }

        // Vari√°veis globais
        let currentUser = null;
        let currentCall = null;
        let currentApartment = null;
        let currentApartmentResidents = [];
        let apartments = [];
        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        let callStartTime = null;
        let callTimer = null;
        let volumeMonitor = null;
        let isMuted = false;
        let webrtcService = null;
        
        // Configura√ß√£o WebRTC
        const rtcConfiguration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Inicializar sistema
        async function initializeSystem() {
            try {
                log('üöÄ Inicializando sistema do porteiro...', 'info');
                log('üì° Conectando com Supabase...', 'info');
                
                // Inicializar WebRTC Service
                webrtcService = new WebRTCService();
                
                // Conectar ao WebSocket
                try {
                    await webrtcService.connectWebSocket();
                    log('‚úÖ WebSocket conectado com sucesso', 'success');
                } catch (error) {
                    log('‚ùå Erro ao conectar WebSocket: ' + error.message, 'error');
                    log('‚ö†Ô∏è Sistema funcionar√° em modo limitado', 'warning');
                }
                
                // Simular login do porteiro
                currentUser = {
                    id: 'porteiro-001',
                    name: 'Porteiro Principal',
                    type: 'porteiro',
                    building_id: null
                };
                
                await loadBuildings();
                updateConnectionStatus('connected', 'üü¢ Conectado - Sistema pronto');
                
                log('‚úÖ Sistema inicializado com sucesso', 'success');
                
            } catch (error) {
                log(`‚ùå Erro na inicializa√ß√£o: ${error.message}`, 'error');
                updateConnectionStatus('disconnected', 'üî¥ Erro na conex√£o');
            }
        }

        // Carregar pr√©dios
        async function loadBuildings() {
            try {
                log('üè¢ Carregando dados dos pr√©dios...', 'info');
                
                const buildings = await webrtcService.getBuildings();
                
                const buildingSelect = document.getElementById('buildingSelect');
                buildingSelect.innerHTML = '<option value="">Selecione um pr√©dio...</option>';
                
                buildings.forEach(building => {
                    const option = document.createElement('option');
                    option.value = building.id;
                    option.textContent = building.name;
                    buildingSelect.appendChild(option);
                });
                
                log(`üè¢ ${buildings.length} pr√©dios carregados com sucesso`, 'success');
                
            } catch (error) {
                log(`‚ùå Erro ao carregar pr√©dios: ${error.message}`, 'error');
            }
        }

        // Buscar apartamento e iniciar chamada
        async function callApartment() {
            try {
                const buildingId = document.getElementById('buildingSelect').value;
                const apartmentNumber = document.getElementById('apartmentInput').value.trim();
                
                if (!buildingId || !apartmentNumber) {
                    log('‚ö†Ô∏è Selecione um pr√©dio e digite o n√∫mero do apartamento', 'warning');
                    return;
                }
                
                log(`üîç Buscando apartamento ${apartmentNumber}...`, 'info');
                
                // Buscar apartamentos do pr√©dio
                apartments = await webrtcService.getBuildingApartments(buildingId);
                
                // Encontrar o apartamento espec√≠fico
                const apartment = apartments.find(apt => apt.number === apartmentNumber);
                
                if (!apartment) {
                    log(`‚ùå Apartamento ${apartmentNumber} n√£o encontrado`, 'error');
                    displayResidents([]);
                    return;
                }
                
                currentApartment = apartment;
                
                // Buscar moradores do apartamento
                currentApartmentResidents = await webrtcService.getApartmentResidents(apartment.number, buildingId);
                
                if (currentApartmentResidents.length === 0) {
                    log(`‚ùå Nenhum morador encontrado no apartamento ${apartmentNumber}`, 'error');
                    displayResidents([]);
                    return;
                }
                
                displayResidents(currentApartmentResidents);
                log(`‚úÖ Apartamento ${apartmentNumber} encontrado com ${currentApartmentResidents.length} moradores`, 'success');
                
                // Iniciar chamada simult√¢nea para todos os moradores
                await startSimultaneousCall(currentApartmentResidents, apartmentNumber);
                
            } catch (error) {
                console.error('Erro ao chamar apartamento:', error);
                log(`‚ùå Erro ao chamar apartamento: ${error.message}`, 'error');
            }
        }

        // Exibir moradores
        function displayResidents(residents) {
            const residentsList = document.getElementById('residentsList');
            
            if (residents.length === 0) {
                residentsList.innerHTML = `
                    <div style="padding: 40px; text-align: center; color: #666;">
                        Nenhum morador encontrado neste apartamento
                    </div>
                `;
                return;
            }
            
            residentsList.innerHTML = residents.map(resident => `
                <div class="resident-item">
                    <div class="resident-info">
                        <div class="resident-name">${resident.full_name}</div>
                        <div class="resident-apartment">${resident.relationship}${resident.is_primary ? ' (Principal)' : ''}${resident.is_owner ? ' (Propriet√°rio)' : ''}</div>
                    </div>
                    <div class="resident-status">
                        Dispon√≠vel
                    </div>
                </div>
            `).join('');
        }

        // Iniciar chamada simult√¢nea para todos os moradores
        async function startSimultaneousCall(residents, apartmentNumber) {
            try {
                log(`üìû Iniciando chamada simult√¢nea para ${residents.length} moradores do apartamento ${apartmentNumber}...`, 'info');
                
                // Verificar se currentApartment est√° definido
                if (!currentApartment || !currentApartment.id) {
                    throw new Error('Apartamento n√£o selecionado ou ID do apartamento n√£o encontrado');
                }
                
                // Mostrar √°rea de status da chamada
                showCallStatusArea();
                updateCallStatusMessage(`Chamando apartamento ${apartmentNumber}...`);
                
                // Inicializar lista de chamadas
                const callingList = residents.map(resident => ({
                    id: resident.profile_id,
                    name: resident.full_name,
                    status: 'calling'
                }));
                
                updateCallingResidentsList(callingList);
                
                // Enviar notifica√ß√£o real para os moradores via WebSocket/Supabase
                log(`üìû Enviando notifica√ß√£o de chamada para ${residents.length} morador(es)...`, 'info');
                
                // Inicializar chamada real via WebSocket
                try {
                    const callResponse = await webrtcService.initiateCall(currentApartment.id, 'Porteiro', residents);
                    
                    if (!callResponse.success) {
                        throw new Error(callResponse.message || 'Erro ao iniciar chamada');
                    }
                    
                    currentCall = {
                        id: callResponse.call_id,
                        apartment: apartmentNumber,
                        residents: residents,
                        status: 'calling',
                        startTime: new Date()
                    };
                    
                    // Aguardar resposta real dos moradores
                    // A resposta vir√° via WebSocket quando um morador aceitar/rejeitar
                    updateCallStatusMessage(`Aguardando resposta dos moradores...`);
                    
                    // Configurar timeout de 30 segundos
                    setTimeout(() => {
                        if (currentCall && currentCall.status === 'calling') {
                            log(`‚è∞ Timeout da chamada - nenhum morador atendeu`, 'warning');
                            updateCallStatusMessage('Chamada n√£o atendida - timeout');
                            
                            callingList.forEach(call => {
                                call.status = 'timeout';
                            });
                            
                            updateCallingResidentsList(callingList);
                            currentCall = null;
                        }
                    }, 30000);
                    
                } catch (error) {
                    log(`‚ùå Erro ao iniciar chamada: ${error.message}`, 'error');
                    updateCallStatusMessage('Erro ao iniciar chamada');
                    
                    callingList.forEach(call => {
                        call.status = 'failed';
                    });
                    
                    updateCallingResidentsList(callingList);
                }
                
            } catch (error) {
                console.error('Erro na chamada simult√¢nea:', error);
                log(`‚ùå Erro na chamada simult√¢nea: ${error.message}`, 'error');
                updateCallStatusMessage('Erro na chamada');
            }
        }

        // Esta fun√ß√£o foi removida - as respostas agora s√£o tratadas via WebSocket
        // nas fun√ß√µes handleCallAccepted e handleCallRejected

        // Estabelecer conex√£o WebRTC
        async function establishConnection(residentId, residentName, apartment) {
            try {
                // Aqui voc√™ implementaria a l√≥gica real do WebRTC
                currentCall = {
                    resident_id: residentId,
                    resident_name: residentName,
                    apartment: apartment,
                    status: 'connected'
                };
                
                callStartTime = new Date();
                
                updateConnectionStatus('connected', `üü¢ Conectado com ${residentName}`);
                
                showCallControls();
                updateCallInfo();
                startCallTimer();
                
                // Inicializar WebRTC se ainda n√£o foi inicializado
                if (!peerConnection) {
                    await initializeWebRTC();
                }
                
                log(`üé§ Conex√£o estabelecida com ${residentName}`, 'success');
                
            } catch (error) {
                console.error('Erro ao estabelecer conex√£o:', error);
                log(`‚ùå Erro ao estabelecer conex√£o: ${error.message}`, 'error');
            }
        }

        // Mostrar √°rea de status da chamada
        function showCallStatusArea() {
            document.getElementById('callStatusArea').style.display = 'block';
        }

        // Ocultar √°rea de status da chamada
        function hideCallStatusArea() {
            document.getElementById('callStatusArea').style.display = 'none';
        }

        // Atualizar mensagem de status da chamada
        function updateCallStatusMessage(message) {
            document.getElementById('callStatusMessage').textContent = message;
        }

        // Atualizar lista de moradores sendo chamados
        function updateCallingResidentsList(callingList) {
            const container = document.getElementById('callingResidents');
            
            container.innerHTML = callingList.map(call => `
                <div class="calling-resident ${call.status}">
                    <div>
                        <div style="font-weight: 600;">${call.name}</div>
                    </div>
                    <div class="calling-status ${call.status}">
                        ${call.status === 'calling' ? 'Chamando...' : 
                          call.status === 'answered' ? 'Atendeu' : 
                          call.status === 'cancelled' ? 'Cancelado' : 'N√£o atendeu'}
                    </div>
                </div>
            `).join('');
        }

        // Iniciar chamada
        async function startCall(residentId, residentName, apartment) {
            try {
                log(`üìû Iniciando chamada para ${residentName} (Apt. ${apartment})...`, 'info');
                
                // Iniciar chamada via API
                const callResponse = await webrtcService.initiateCall(currentApartment.id, 'Porteiro');
                
                if (!callResponse.success) {
                    throw new Error(callResponse.message || 'Erro ao iniciar chamada');
                }
                
                // Configurar informa√ß√µes da chamada
                currentCall = {
                    id: callResponse.call_id,
                    resident_id: residentId,
                    resident_name: residentName,
                    apartment: apartment,
                    status: 'calling'
                };
                
                // Atualizar interface
                updateConnectionStatus('calling', `üü° Chamando ${residentName} - Apt. ${apartment}`);
                showCallControls();
                updateCallInfo();
                
                // Inicializar WebRTC
                await initializeWebRTC();
                
                // Simular resposta ap√≥s alguns segundos
                setTimeout(() => {
                    if (currentCall && currentCall.status === 'calling') {
                        simulateCallAnswer();
                    }
                }, 3000);
                
            } catch (error) {
                log(`‚ùå Erro ao iniciar chamada: ${error.message}`, 'error');
                endCall();
            }
        }

        // Inicializar WebRTC
        async function initializeWebRTC() {
            try {
                // Obter stream de √°udio
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                // Criar peer connection
                peerConnection = new RTCPeerConnection(rtcConfiguration);
                
                // Adicionar stream local
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
                
                // Configurar eventos
                peerConnection.ontrack = (event) => {
                    remoteStream = event.streams[0];
                    log('üì• Stream remoto recebido', 'success');
                    
                    // Conectar stream remoto ao elemento de √°udio
                    const remoteAudio = document.getElementById('remoteAudio');
                    if (remoteAudio && remoteStream) {
                        remoteAudio.srcObject = remoteStream;
                        remoteAudio.volume = document.getElementById('remoteVolumeSlider').value;
                        
                        // Tentar reproduzir o √°udio
                        remoteAudio.play().then(() => {
                            log('üîä √Åudio remoto iniciado com sucesso', 'success');
                        }).catch(error => {
                            log(`‚ö†Ô∏è Erro ao iniciar √°udio remoto: ${error.message}`, 'warning');
                            // Tentar novamente ap√≥s intera√ß√£o do usu√°rio
                            document.addEventListener('click', () => {
                                remoteAudio.play().catch(e => console.warn('Erro ao reproduzir √°udio:', e));
                            }, { once: true });
                        });
                    }
                };
                
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        log('üßä ICE candidate gerado', 'info');
                    }
                };
                
                peerConnection.onconnectionstatechange = () => {
                    log(`üîó Estado da conex√£o: ${peerConnection.connectionState}`, 'info');
                };
                
                // Iniciar monitoramento de volume
                startVolumeMonitoring();
                
                log('üé§ WebRTC inicializado com sucesso', 'success');
                
            } catch (error) {
                throw new Error(`Falha na inicializa√ß√£o WebRTC: ${error.message}`);
            }
        }

        // Simular resposta da chamada
        function simulateCallAnswer() {
            if (currentCall) {
                currentCall.status = 'connected';
                callStartTime = new Date();
                
                updateConnectionStatus('connected', `üü¢ Conectado com ${currentCall.resident_name}`);
                
                document.getElementById('answerCall').disabled = true;
                document.getElementById('endCall').disabled = false;
                
                startCallTimer();
                log(`‚úÖ Chamada atendida por ${currentCall.resident_name}`, 'success');
            }
        }

        // Atender chamada (para chamadas recebidas)
        function answerCall() {
            if (currentCall && currentCall.status === 'calling') {
                simulateCallAnswer();
            }
        }

        // Encerrar chamada
        function endCall() {
            try {
                if (currentCall) {
                    log(`üì¥ Encerrando chamada com ${currentCall.resident_name}...`, 'info');
                }
                
                // Parar streams
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                
                if (remoteStream) {
                    remoteStream.getTracks().forEach(track => track.stop());
                    remoteStream = null;
                }
                
                // Fechar peer connection
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                
                // Parar timers
                if (callTimer) {
                    clearInterval(callTimer);
                    callTimer = null;
                }
                
                if (volumeMonitor) {
                    clearInterval(volumeMonitor);
                    volumeMonitor = null;
                }
                
                // Resetar interface
                currentCall = null;
                callStartTime = null;
                isMuted = false;
                
                hideCallControls();
                updateConnectionStatus('connected', 'üü¢ Conectado - Sistema pronto');
                
                log('‚úÖ Chamada encerrada', 'success');
                
            } catch (error) {
                log(`‚ùå Erro ao encerrar chamada: ${error.message}`, 'error');
            }
        }

        // Alternar mute
        function toggleMute() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                    isMuted = !audioTrack.enabled;
                    
                    const muteButton = document.getElementById('muteButton');
                    muteButton.innerHTML = isMuted ? '<span>üîä</span> Unmute' : '<span>üîá</span> Mute';
                    
                    log(`${isMuted ? 'üîá' : 'üîä'} Microfone ${isMuted ? 'mutado' : 'desmutado'}`, 'info');
                }
            }
        }

        // Testar microfone
        async function testMicrophone() {
            try {
                log('üé§ Testando microfone...', 'info');
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Criar contexto de √°udio para teste
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(stream);
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                let testDuration = 3000;
                let maxVolume = 0;
                
                const testInterval = setInterval(() => {
                    analyser.getByteFrequencyData(dataArray);
                    
                    let sum = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        sum += dataArray[i];
                    }
                    const volume = sum / bufferLength;
                    maxVolume = Math.max(maxVolume, volume);
                    
                    testDuration -= 100;
                    
                    if (testDuration <= 0) {
                        clearInterval(testInterval);
                        stream.getTracks().forEach(track => track.stop());
                        
                        if (maxVolume > 10) {
                            log('‚úÖ Microfone funcionando corretamente!', 'success');
                        } else {
                            log('‚ö†Ô∏è Microfone muito baixo ou n√£o detectado', 'warning');
                        }
                    }
                }, 100);
                
                log('üîä Fale algo para testar o microfone (3 segundos)...', 'info');
                
            } catch (error) {
                log(`‚ùå Erro no teste do microfone: ${error.message}`, 'error');
            }
        }

        // Iniciar monitoramento de volume
        function startVolumeMonitoring() {
            if (!localStream) return;
            
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(localStream);
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                volumeMonitor = setInterval(() => {
                    analyser.getByteFrequencyData(dataArray);
                    
                    let sum = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        sum += dataArray[i];
                    }
                    const volume = (sum / bufferLength / 255) * 100;
                    
                    const volumeLevel = document.getElementById('volumeLevel');
                    if (volumeLevel) {
                        volumeLevel.style.width = `${volume}%`;
                    }
                }, 100);
                
            } catch (error) {
                log(`‚ùå Erro no monitoramento de volume: ${error.message}`, 'error');
            }
        }

        // Iniciar timer da chamada
        function startCallTimer() {
            callTimer = setInterval(() => {
                if (callStartTime) {
                    const duration = Math.floor((new Date() - callStartTime) / 1000);
                    const minutes = Math.floor(duration / 60);
                    const seconds = duration % 60;
                    
                    document.getElementById('callDuration').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        // Mostrar controles da chamada
        function showCallControls() {
            document.getElementById('callControls').style.display = 'grid';
            document.getElementById('callInfo').style.display = 'block';
        }

        // Ocultar controles da chamada
        function hideCallControls() {
            document.getElementById('callControls').style.display = 'none';
            document.getElementById('callInfo').style.display = 'none';
        }

        // Atualizar informa√ß√µes da chamada
        function updateCallInfo() {
            if (currentCall) {
                document.getElementById('currentResident').textContent = currentCall.resident_name;
                document.getElementById('currentApartment').textContent = currentCall.apartment;
                document.getElementById('callStatus').textContent = 
                    currentCall.status === 'calling' ? 'Chamando...' : 
                    currentCall.status === 'connected' ? 'Conectado' : 'Desconectado';
            }
        }

        // Atualizar status da conex√£o
        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connectionStatus');
            statusElement.className = `connection-status ${status}`;
            statusElement.innerHTML = `<span>${status === 'connected' ? 'üü¢' : status === 'calling' ? 'üü°' : 'üî¥'}</span><span>${message}</span>`;
        }

        // Ajustar volume do √°udio remoto
        function adjustRemoteVolume(volume) {
            const remoteAudio = document.getElementById('remoteAudio');
            const volumeValue = document.getElementById('remoteVolumeValue');
            
            if (remoteAudio) {
                remoteAudio.volume = parseFloat(volume);
                volumeValue.textContent = `${Math.round(volume * 100)}%`;
                log(`üîä Volume do √°udio remoto ajustado para ${Math.round(volume * 100)}%`, 'info');
            }
        }

        // Fun√ß√£o de log
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // Manter apenas os √∫ltimos 50 logs
            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }

        // Inicializar quando a p√°gina carregar
        window.onload = initializeSystem;

        // Cleanup ao fechar a p√°gina
        window.onbeforeunload = function() {
            if (currentCall) {
                endCall();
            }
        };
    </script>
</body>
</html>